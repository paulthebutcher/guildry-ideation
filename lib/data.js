export const PRODUCTS = {
  scout: { name: "Scout", color: "#b45309", phase: "Notice", tagline: "Competitive & market intelligence monitor", icon: "◉" },
  compass: { name: "Compass", color: "#4f46e5", phase: "Decide", tagline: "AI-powered strategic decision tool", icon: "◆" },
  blueprint: { name: "Blueprint", color: "#0d9488", phase: "Scope", tagline: "Project estimation & scoping engine", icon: "▲" },
  bench: { name: "Bench", color: "#dc2626", phase: "Staff", tagline: "Team capacity & talent matching", icon: "●" },
  relay: { name: "Relay", color: "#7c3aed", phase: "Manage", tagline: "AI client communication layer", icon: "◈" },
  retro: { name: "Retro", color: "#db2777", phase: "Learn", tagline: "Project retrospective & knowledge engine", icon: "◎" },
  proof: { name: "Proof", color: "#059669", phase: "Sell", tagline: "Dynamic case study & proof generator", icon: "◻" },
};

export const PRODUCT_KEYS = Object.keys(PRODUCTS);

export const PIPELINE_PHASES = [
  { key: "scout", label: "Notice" },
  { key: "compass", label: "Decide" },
  { key: "blueprint", label: "Scope" },
  { key: "bench", label: "Staff" },
  { key: "relay", label: "Manage" },
  { key: "retro", label: "Learn" },
  { key: "proof", label: "Sell" },
];

export const LAYERS = [
  {
    id: "core",
    name: "Core Identity",
    description: "Entities that exist independent of any product — the foundational objects everything else references.",
    entities: [
      {
        id: "organization",
        name: "Organization",
        desc: "The user's company, agency, or freelance practice. Top-level tenant.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "name", type: "string" },
          { name: "slug", type: "string" },
          { name: "type", type: "enum", values: "freelancer | agency | studio" },
          { name: "industry_tags", type: "string[]" },
          { name: "created_at", type: "timestamp" },
        ],
        usedBy: ["scout", "compass", "blueprint", "bench", "relay", "retro", "proof"],
      },
      {
        id: "user",
        name: "User",
        desc: "A person who uses the platform. May belong to one or more orgs.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "email", type: "string" },
          { name: "name", type: "string" },
          { name: "role", type: "enum", values: "owner | admin | member" },
          { name: "preferences", type: "jsonb" },
        ],
        usedBy: ["scout", "compass", "blueprint", "bench", "relay", "retro", "proof"],
      },
      {
        id: "client",
        name: "Client",
        desc: "An external company or individual you do work for. Central to revenue tracking.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "name", type: "string" },
          { name: "industry", type: "string" },
          { name: "size_tier", type: "enum", values: "startup | smb | mid | enterprise" },
          { name: "website_url", type: "string" },
          { name: "communication_prefs", type: "jsonb" },
          { name: "lifetime_value", type: "decimal" },
        ],
        usedBy: ["blueprint", "relay", "retro", "proof", "scout"],
      },
    ],
  },
  {
    id: "people",
    name: "People & Capabilities",
    description: "The talent graph — who can do what, at what rate, and when they're available.",
    entities: [
      {
        id: "person",
        name: "Person",
        desc: "Anyone in your talent network: employees, contractors, referrals.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "name", type: "string" },
          { name: "type", type: "enum", values: "employee | contractor | referral" },
          { name: "email", type: "string" },
          { name: "location", type: "string" },
          { name: "hourly_rate", type: "decimal" },
          { name: "currency", type: "string" },
          { name: "availability_status", type: "enum", values: "available | partial | booked | unavailable" },
          { name: "rating", type: "decimal" },
          { name: "notes", type: "text" },
        ],
        usedBy: ["bench", "blueprint", "retro"],
      },
      {
        id: "skill",
        name: "Skill",
        desc: "A canonical capability. Used to match people to roles and identify gaps.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "name", type: "string" },
          { name: "category", type: "enum", values: "design | engineering | strategy | ops | marketing | data" },
          { name: "market_rate_p25", type: "decimal" },
          { name: "market_rate_p50", type: "decimal" },
          { name: "market_rate_p75", type: "decimal" },
          { name: "rate_geography", type: "string" },
        ],
        usedBy: ["bench", "blueprint"],
      },
      {
        id: "person_skill",
        name: "PersonSkill",
        desc: "Junction: maps a person to their skills with proficiency.",
        fields: [
          { name: "person_id", type: "uuid", key: "fk", ref: "person" },
          { name: "skill_id", type: "uuid", key: "fk", ref: "skill" },
          { name: "proficiency", type: "enum", values: "junior | mid | senior | expert" },
          { name: "years_exp", type: "integer" },
          { name: "verified_by_projects", type: "uuid[]" },
        ],
        usedBy: ["bench", "blueprint"],
      },
    ],
  },
  {
    id: "projects",
    name: "Projects & Scoping",
    description: "The work itself — from initial estimate through staffing and phase planning.",
    entities: [
      {
        id: "project",
        name: "Project",
        desc: "The central entity. Every product touches this.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "client_id", type: "uuid", key: "fk", ref: "client" },
          { name: "decision_id", type: "uuid", key: "fk", ref: "decision", note: "nullable — Compass link" },
          { name: "name", type: "string" },
          { name: "status", type: "enum", values: "draft | scoping | proposed | active | paused | complete | cancelled" },
          { name: "type", type: "enum", values: "new_build | redesign | fix | audit | retainer | strategy" },
          { name: "estimated_hours", type: "decimal" },
          { name: "actual_hours", type: "decimal" },
          { name: "estimated_cost", type: "decimal" },
          { name: "actual_cost", type: "decimal" },
          { name: "start_date", type: "date" },
          { name: "end_date", type: "date" },
          { name: "tags", type: "string[]" },
        ],
        usedBy: ["blueprint", "bench", "relay", "retro", "proof", "compass"],
      },
      {
        id: "phase",
        name: "Phase",
        desc: "A distinct stage of a project (discovery, design, build, QA, launch).",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "project_id", type: "uuid", key: "fk", ref: "project" },
          { name: "name", type: "string" },
          { name: "order", type: "integer" },
          { name: "estimated_hours", type: "decimal" },
          { name: "actual_hours", type: "decimal" },
          { name: "start_date", type: "date" },
          { name: "end_date", type: "date" },
          { name: "status", type: "enum", values: "planned | active | complete" },
        ],
        usedBy: ["blueprint", "relay", "retro"],
      },
      {
        id: "role_requirement",
        name: "RoleRequirement",
        desc: "A staffing slot within a phase.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "phase_id", type: "uuid", key: "fk", ref: "phase" },
          { name: "skill_id", type: "uuid", key: "fk", ref: "skill" },
          { name: "person_id", type: "uuid", key: "fk", ref: "person", note: "nullable until staffed" },
          { name: "seniority", type: "enum", values: "junior | mid | senior | lead" },
          { name: "hours", type: "decimal" },
          { name: "rate_override", type: "decimal" },
          { name: "is_gap", type: "boolean", note: "true = no one in network can fill" },
        ],
        usedBy: ["blueprint", "bench"],
      },
    ],
  },
  {
    id: "intelligence",
    name: "Intelligence & Decisions",
    description: "Market signals, strategic decisions, and the audit data that informs both.",
    entities: [
      {
        id: "signal_item",
        name: "SignalItem",
        desc: "A detected market event: competitor change, funding round, pricing shift.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "source_type", type: "enum", values: "website | job_board | press | g2 | social | funding" },
          { name: "source_url", type: "string" },
          { name: "entity_name", type: "string" },
          { name: "summary", type: "text" },
          { name: "relevance_score", type: "decimal" },
          { name: "detected_at", type: "timestamp" },
          { name: "tags", type: "string[]" },
        ],
        usedBy: ["scout", "compass"],
      },
      {
        id: "site_audit",
        name: "SiteAudit",
        desc: "Technical analysis of a website: performance, accessibility, tech stack.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "project_id", type: "uuid", key: "fk", ref: "project", note: "nullable" },
          { name: "client_id", type: "uuid", key: "fk", ref: "client", note: "nullable" },
          { name: "url", type: "string" },
          { name: "lighthouse_scores", type: "jsonb" },
          { name: "tech_stack", type: "string[]" },
          { name: "accessibility_issues", type: "integer" },
          { name: "seo_score", type: "decimal" },
          { name: "fix_estimate_hours", type: "decimal" },
          { name: "rebuild_estimate_hours", type: "decimal" },
          { name: "recommendation", type: "enum", values: "fix | rebuild | hybrid" },
          { name: "raw_data", type: "jsonb" },
          { name: "audited_at", type: "timestamp" },
        ],
        usedBy: ["blueprint", "compass", "proof"],
      },
      {
        id: "decision",
        name: "Decision",
        desc: "A strategic decision modeled in Compass.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "title", type: "string" },
          { name: "context", type: "text" },
          { name: "status", type: "enum", values: "exploring | evaluating | decided | revisiting" },
          { name: "chosen_option_id", type: "uuid", key: "fk", ref: "decision_option" },
          { name: "decided_at", type: "timestamp" },
          { name: "signal_ids", type: "uuid[]", note: "signals that triggered this" },
        ],
        usedBy: ["compass", "blueprint"],
      },
      {
        id: "decision_option",
        name: "DecisionOption",
        desc: "One possible path within a decision, with scored criteria.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "decision_id", type: "uuid", key: "fk", ref: "decision" },
          { name: "title", type: "string" },
          { name: "description", type: "text" },
          { name: "scores", type: "jsonb", note: "{ criterion: score } pairs" },
          { name: "total_score", type: "decimal" },
          { name: "project_id", type: "uuid", key: "fk", ref: "project", note: "nullable — linked if scoped" },
        ],
        usedBy: ["compass"],
      },
    ],
  },
  {
    id: "communication",
    name: "Communication & Documents",
    description: "Everything generated, sent, and tracked across the client relationship.",
    entities: [
      {
        id: "document",
        name: "Document",
        desc: "Any generated artifact: SOW, proposal, case study, decision brief.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "project_id", type: "uuid", key: "fk", ref: "project", note: "nullable" },
          { name: "client_id", type: "uuid", key: "fk", ref: "client", note: "nullable" },
          { name: "type", type: "enum", values: "sow | proposal | case_study | status_report | change_order | decision_brief | retro_report" },
          { name: "title", type: "string" },
          { name: "content", type: "text" },
          { name: "template_id", type: "uuid" },
          { name: "format", type: "enum", values: "pdf | docx | md | html" },
          { name: "version", type: "integer" },
          { name: "status", type: "enum", values: "draft | review | sent | signed" },
          { name: "file_url", type: "string" },
          { name: "created_at", type: "timestamp" },
        ],
        usedBy: ["blueprint", "relay", "proof", "retro", "compass"],
      },
      {
        id: "communication_log",
        name: "CommunicationLog",
        desc: "A record of client-facing communication with scope drift detection.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "project_id", type: "uuid", key: "fk", ref: "project" },
          { name: "client_id", type: "uuid", key: "fk", ref: "client" },
          { name: "direction", type: "enum", values: "inbound | outbound" },
          { name: "channel", type: "enum", values: "email | slack | call | meeting" },
          { name: "raw_content", type: "text" },
          { name: "ai_summary", type: "text" },
          { name: "scope_drift_flag", type: "boolean" },
          { name: "drift_details", type: "text" },
          { name: "action_items", type: "jsonb" },
          { name: "logged_at", type: "timestamp" },
        ],
        usedBy: ["relay", "retro"],
      },
    ],
  },
  {
    id: "learning",
    name: "Learning & Knowledge",
    description: "The feedback loop — structured retrospective data that compounds over time.",
    entities: [
      {
        id: "retrospective",
        name: "Retrospective",
        desc: "A structured post-mortem tied to a project.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "project_id", type: "uuid", key: "fk", ref: "project" },
          { name: "completed_at", type: "timestamp" },
          { name: "hours_variance_pct", type: "decimal" },
          { name: "cost_variance_pct", type: "decimal" },
          { name: "scope_changes_count", type: "integer" },
          { name: "client_satisfaction", type: "enum", values: "1 | 2 | 3 | 4 | 5" },
          { name: "what_worked", type: "text" },
          { name: "what_didnt", type: "text" },
          { name: "lessons", type: "text[]" },
          { name: "would_repeat", type: "boolean" },
          { name: "tags", type: "string[]" },
        ],
        usedBy: ["retro", "blueprint", "proof"],
      },
      {
        id: "phase_performance",
        name: "PhasePerformance",
        desc: "Per-phase actuals vs. estimates.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "retro_id", type: "uuid", key: "fk", ref: "retrospective" },
          { name: "phase_id", type: "uuid", key: "fk", ref: "phase" },
          { name: "phase_name", type: "string" },
          { name: "estimated_hours", type: "decimal" },
          { name: "actual_hours", type: "decimal" },
          { name: "variance_pct", type: "decimal" },
          { name: "notes", type: "text" },
        ],
        usedBy: ["retro", "blueprint"],
      },
      {
        id: "estimation_model",
        name: "EstimationModel",
        desc: "Learned coefficients that adjust future estimates from retro data.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "org_id", type: "uuid", key: "fk", ref: "organization" },
          { name: "project_type", type: "string" },
          { name: "industry", type: "string" },
          { name: "team_size_range", type: "string" },
          { name: "avg_hours_variance", type: "decimal" },
          { name: "avg_cost_variance", type: "decimal" },
          { name: "phase_adjustments", type: "jsonb", note: "{ phase_name: multiplier }" },
          { name: "confidence_level", type: "decimal" },
          { name: "sample_size", type: "integer" },
          { name: "last_updated", type: "timestamp" },
        ],
        usedBy: ["blueprint", "retro"],
      },
    ],
  },
  {
    id: "ai",
    name: "AI Orchestration",
    description: "The shared conversational engine — intake sessions, tool calls, and generated outputs.",
    entities: [
      {
        id: "conversation",
        name: "Conversation",
        desc: "An AI interaction session. Same pattern, different schemas per product.",
        fields: [
          { name: "id", type: "uuid", key: "pk" },
          { name: "user_id", type: "uuid", key: "fk", ref: "user" },
          { name: "product", type: "enum", values: "scout | compass | blueprint | bench | relay | retro | proof" },
          { name: "intent", type: "string", note: "what the user is trying to accomplish" },
          { name: "schema_target", type: "string", note: "which entity schema is being filled" },
          { name: "status", type: "enum", values: "active | complete | abandoned" },
          { name: "messages", type: "jsonb[]" },
          { name: "extracted_data", type: "jsonb" },
          { name: "created_entities", type: "jsonb", note: "{ entity_type: id } pairs" },
          { name: "started_at", type: "timestamp" },
          { name: "completed_at", type: "timestamp" },
        ],
        usedBy: ["scout", "compass", "blueprint", "bench", "relay", "retro", "proof"],
      },
    ],
  },
];

export const RELATIONSHIPS = [
  { from: "organization", to: "user", label: "has many", type: "one-many" },
  { from: "organization", to: "client", label: "has many", type: "one-many" },
  { from: "organization", to: "person", label: "has many", type: "one-many" },
  { from: "organization", to: "project", label: "has many", type: "one-many" },
  { from: "client", to: "project", label: "has many", type: "one-many" },
  { from: "project", to: "phase", label: "has many", type: "one-many" },
  { from: "phase", to: "role_requirement", label: "has many", type: "one-many" },
  { from: "role_requirement", to: "skill", label: "requires", type: "many-one" },
  { from: "role_requirement", to: "person", label: "filled by", type: "many-one" },
  { from: "person", to: "person_skill", label: "has many", type: "one-many" },
  { from: "skill", to: "person_skill", label: "has many", type: "one-many" },
  { from: "decision", to: "decision_option", label: "has many", type: "one-many" },
  { from: "decision_option", to: "project", label: "spawns", type: "one-one" },
  { from: "decision", to: "project", label: "spawns via option", type: "one-one" },
  { from: "signal_item", to: "decision", label: "triggers", type: "many-many" },
  { from: "project", to: "document", label: "has many", type: "one-many" },
  { from: "project", to: "communication_log", label: "has many", type: "one-many" },
  { from: "project", to: "retrospective", label: "has one", type: "one-one" },
  { from: "retrospective", to: "phase_performance", label: "has many", type: "one-many" },
  { from: "retrospective", to: "estimation_model", label: "feeds", type: "many-one" },
  { from: "site_audit", to: "project", label: "informs", type: "many-one" },
  { from: "user", to: "conversation", label: "has many", type: "one-many" },
];

export const PRODUCT_DETAILS = {
  scout: {
    problem: "Before you can make a decision, you need to notice something worth deciding about. Freelancers and product leads waste hours scanning competitors, reading funding announcements, and trying to spot positioning shifts.",
    solution: "Feed it competitors, market segments, or client industries. It continuously monitors public signals — website changes, job postings, press releases, pricing page updates, G2 reviews — and surfaces actionable briefs.",
    entities: ["signal_item", "organization", "client"],
    outputs: ["Competitive intelligence briefs", "Market shift alerts", "Opportunity triggers"],
    techStack: ["Web scrapers (Puppeteer/Playwright)", "RSS/webhook integrations", "Claude API for summarization", "Cron-based monitoring"],
    bridgeTo: "Scout detects an opportunity → triggers a Compass decision → which spawns a Blueprint scope.",
  },
  compass: {
    problem: "Strategic decisions get stuck in endless discussion or gut-feel calls. There's no structured way to evaluate options, weight criteria, and document the reasoning for future reference.",
    solution: "AI-guided decision framework that helps you define options, score them against weighted criteria, and produce a decision brief. The AI asks the right questions to surface hidden assumptions and blind spots.",
    entities: ["decision", "decision_option", "signal_item", "project"],
    outputs: ["Decision matrices", "Recommendation briefs", "Option comparisons", "Risk assessments"],
    techStack: ["Claude API with function calling", "Weighted scoring engine", "Template-based document generation"],
    bridgeTo: "A decided option can spawn a Blueprint project scope with one click.",
  },
  blueprint: {
    problem: "Freelancers and agencies consistently underestimate projects, lose money on fixed-bid work, and spend hours building proposals manually. Scoping is art when it should be data-informed craft.",
    solution: "Conversational intake that builds a full project scope: phases, roles, hours, costs, and deliverables. Scrapes client websites for technical audit data. Generates SOWs and proposals from the structured scope.",
    entities: ["project", "phase", "role_requirement", "site_audit", "document"],
    outputs: ["Project scopes", "SOWs & proposals", "Fix vs. rebuild analyses", "Cost breakdowns"],
    techStack: ["Lighthouse/Puppeteer for site audits", "Claude API for conversational scoping", "Market rate database", "Document generation pipeline"],
    bridgeTo: "Completed scopes feed into Bench for staffing, Relay for project management, and Retro for learning.",
  },
  bench: {
    problem: "You know what roles you need but not who's available, who's good, or where you have gaps. Staffing decisions happen in your head or a messy spreadsheet, and you only realize you're missing a skill when it's too late.",
    solution: "Lightweight talent CRM mapping your network with skills, rates, availability, and performance history. When Blueprint generates a team plan, Bench matches real people to abstract roles and flags gaps.",
    entities: ["person", "skill", "person_skill", "role_requirement"],
    outputs: ["Staffing recommendations", "Gap analysis reports", "Availability dashboards", "Rate comparisons"],
    techStack: ["Skill taxonomy with market rates", "Matching algorithm", "Calendar/availability integration", "Claude API for natural language talent queries"],
    bridgeTo: "Bench assigns real people to Blueprint's role requirements. Performance data from Retro improves future matching.",
  },
  relay: {
    problem: "30% of project time goes to communication translation: technical progress into client updates, vague feedback into requirements, scope creep into change order conversations. Bad communication kills accounts.",
    solution: "Dump raw notes or Slack threads. It drafts client-facing updates, flags scope creep against the SOW, generates change order requests, and learns your tone and client preferences over time.",
    entities: ["communication_log", "document", "project", "client"],
    outputs: ["Status reports", "Change order requests", "Meeting summaries", "Scope drift alerts"],
    techStack: ["Claude API for tone-matched writing", "SOW comparison engine for drift detection", "Email/Slack integrations", "Action item extraction"],
    bridgeTo: "Relay reads Blueprint's SOW to detect drift. Communication data feeds Retro's retrospectives.",
  },
  retro: {
    problem: "Every project contains lessons that could improve the next estimate, proposal, and team configuration. But retros are tedious, and even when they happen, insights rot in a Google Doc.",
    solution: "Async conversational retrospective that asks structured questions about scope variance, time allocation, client satisfaction, and lessons learned. Builds a compounding knowledge base.",
    entities: ["retrospective", "phase_performance", "estimation_model", "project"],
    outputs: ["Retro reports", "Estimation calibration data", "Performance benchmarks", "Pattern analysis"],
    techStack: ["Claude API for guided retro conversations", "Statistical analysis for variance patterns", "Time series data for estimation model training"],
    bridgeTo: "Retro data feeds into Blueprint's estimation models and Bench's performance ratings. This is the learning layer.",
  },
  proof: {
    problem: "Your best sales asset is past work, but packaging it is painful. Case studies go stale, portfolios are generic, and when a prospect asks 'have you done anything like X?' you're scrambling.",
    solution: "Feed it project data and deliverables. It generates tailored case studies, portfolio pages, and proof-of-relevance briefs dynamically tuned to the prospect's context.",
    entities: ["document", "retrospective", "project", "client", "site_audit"],
    outputs: ["Dynamic case studies", "Prospect-tuned portfolios", "Proof-of-relevance briefs", "Win/loss analyses"],
    techStack: ["Claude API for narrative generation", "Template engine for multiple formats", "Project data aggregation", "Prospect context matching"],
    bridgeTo: "Proof pulls from Retro's data and Blueprint's scope history. When Relay detects a sales conversation, Proof drafts supporting materials.",
  },
};

export const ARCHITECTURE_PRINCIPLES = [
  {
    title: "Single ownership, shared reads",
    desc: "Each entity is written by one product but can be read by many. Project is owned by Blueprint but read by Relay, Retro, and Proof. This prevents write conflicts and makes the ownership model clear.",
    icon: "✦",
  },
  {
    title: "Nullable foreign keys as bridges",
    desc: "Cross-product references are always nullable. A Project can exist without a Decision (no Compass). A Document can exist without a Project. Each product works standalone.",
    icon: "◇",
  },
  {
    title: "JSONB for evolving schemas",
    desc: "Fields like scores, phase_adjustments, and preferences use JSONB. Each product can extend the shape without migrations. The shared layer stays stable while product-specific data evolves.",
    icon: "{ }",
  },
  {
    title: "Conversation as universal intake",
    desc: "Every product uses the same Conversation entity with a different schema_target. One codebase fills any entity through guided AI interaction.",
    icon: "◎",
  },
  {
    title: "Retro → EstimationModel feedback loop",
    desc: "PhasePerformance data from completed projects feeds into EstimationModel coefficients. Over time, Blueprint's estimates self-correct using real project data.",
    icon: "↻",
  },
  {
    title: "Document as universal output",
    desc: "SOWs, proposals, case studies, and decision briefs are all the same entity with a type enum. One doc-gen pipeline, many templates.",
    icon: "▤",
  },
];

export const REPO_STRUCTURE = {
  shared: [
    { path: "/intake-engine", desc: "Conversational schema-filling logic" },
    { path: "/llm-client", desc: "Claude API wrapper, tool orchestration" },
    { path: "/doc-gen", desc: "Template rendering to PDF/DOCX" },
    { path: "/ui-primitives", desc: "Shared React components" },
    { path: "/auth", desc: "User/org/billing" },
    { path: "/db", desc: "Prisma schema, migrations, seed data" },
  ],
  products: Object.entries(PRODUCTS).map(([key, prod]) => ({
    key,
    name: prod.name,
    paths: [
      { path: `/domain`, desc: `${prod.name}-specific models & logic` },
      { path: `/tools`, desc: "Function calling definitions for Claude API" },
      { path: `/templates`, desc: "Document templates" },
      { path: `/app`, desc: "Next.js frontend" },
    ],
  })),
};

// GTM: Integrated platform from day 1, staged rollout
export const ROADMAP_PHASES = [
  {
    phase: "Phase 0",
    name: "Foundation",
    timeline: "Weeks 1–3",
    color: "#0d9488",
    items: [
      "Monorepo setup (Turborepo + pnpm)",
      "Shared Postgres schema + Prisma",
      "Auth layer (Clerk or NextAuth)",
      "Claude API wrapper with function calling",
      "Conversational intake engine v1",
      "Basic UI component library",
    ],
    milestone: "Shared infra deployed. Can create orgs, users, and run AI conversations.",
  },
  {
    phase: "Phase 1",
    name: "Core Project Loop",
    timeline: "Weeks 4–10",
    color: "#0d9488",
    items: [
      "Blueprint: Conversational project scoping",
      "Blueprint: SOW + proposal generation",
      "Bench: Talent CRM with skills/rates",
      "Bench: Match people to Blueprint roles",
      "Retro: Async retrospective flow",
      "Retro: Estimation model v1",
    ],
    milestone: "Closed feedback loop: scope → staff → deliver → learn → improve estimates. Data flywheel starts turning.",
  },
  {
    phase: "Phase 2",
    name: "Client & Sales Layer",
    timeline: "Weeks 11–18",
    color: "#7c3aed",
    items: [
      "Relay: Client communication drafting",
      "Relay: Scope drift detection vs. SOW",
      "Relay: Change order generation",
      "Proof: Dynamic case study generator",
      "Proof: Prospect-tuned briefs",
      "Cross-product data flows",
    ],
    milestone: "Full client lifecycle managed. Communication and sales collateral auto-generated from project data.",
  },
  {
    phase: "Phase 3",
    name: "Strategy Layer",
    timeline: "Weeks 19–26",
    color: "#b45309",
    items: [
      "Scout: Market monitoring engine",
      "Scout: Competitive intelligence briefs",
      "Compass: Decision framework with scoring",
      "Compass: Scout → Decision → Project pipeline",
      "Cross-product workspace view",
      "Platform-level analytics dashboard",
    ],
    milestone: "Full pipeline: detect opportunity → decide → scope → staff → manage → learn → sell.",
  },
];
